# =================================================================================================
# CLEAN DATA / SET UP WORKING ENVIRONMENT

# Author: Michael Jetsupphasuk
# Last Updated: 11 December, 2017

# This file creates the relevant data frames and Spatial objects for further analysis. 

# Oklahoma Boundaries:
#     - Loads boundaries from map_data from `ggplot2`, `maps` packages
#     - Creates data in following formats:
#         + data frame
#         + spatial points data frame (`sp`)
#         + spatial polygon (`sp`)

# Grid:
#     - Creates a 0.2 x 0.2 degree long/lat grid
#     - Creates a spatial grid (`sp`)

# Earthquakes:
#     - See scrape/get_eq.R for query information
#     - Filter earthquakes for only ones in oklahoma
#     - Earthquakes mapped to grid (from above)
#     - Creates a data frame

# Wells:
#     - See scrape/get_inj_ok.R for injection information
#     - Links various data frames together to gather all relevant information
#     - Wells mapped to grid (from above)
#     - Handles missing data
#         + appends 0 injection for dates before first / after last
#         + missing dates in between the first and last date have injection equal
#           to the average of the nearest injections before/after the missing
#     - Creates data in following formats:
#         + long data frame (each row a combination of well, injection date)
#         + wide data frame (each row is a unique well)
#         + spatial points data frame (wide data)

# =================================================================================================

# LOAD LIBRARIES ----------------------------------------------------------

library(dplyr)
library(stringr)
library(tidyr)

library(maps)
library(maptools)

library(sp)  # vector data
library(raster)  # raster data
library(rgdal)  # input/output, projections
library(rgeos)  # geometry ops
library(spdep)  # spatial dependence

library(ggmap)
# citation('ggmap')

library(spatstat)


# GLOBAL PARAMETERS -------------------------------------------------------

my_crs = CRS( "+proj=longlat +ellps=WGS84 +datum=WGS84" )


# OKLAHOMA BOUNDARIES ---------------------------------------------------

# get oklahoma boundaries
okl = map_data("state") %>% filter(region == 'oklahoma')

# convert boundaries to a SpatialPointsDataFrame
okl_points = SpatialPointsDataFrame(coords = okl %>% dplyr::select(long, lat),
                                    data = data.frame(ID = 1:nrow(okl)),
                                    proj4string = CRS( "+proj=longlat +ellps=WGS84 +datum=WGS84" ))

# convert boundaries to a SpatialPolygon
okl_poly = Polygon(okl[ , c("long", "lat")])
okl_polys = Polygons(list(okl_poly), 1)
okl_spolys = SpatialPolygons(list(okl_polys))
proj4string(okl_spolys) = CRS( "+proj=longlat +ellps=WGS84 +datum=WGS84" )


# GRID --------------------------------------------------------------------

# create grid from oklahoma points data
grid = makegrid(okl_points, cellsize = 0.2)
grid = SpatialPoints(grid, proj4string = my_crs)
grid = points2grid(grid)
grid_sp = SpatialGrid(grid, proj4string = my_crs)

# grid_sp_df = SpatialGridDataFrame(grid, data.frame(value = 1:length(grid_sp)),
#                                   proj4string = my_crs)
# grid_df = data.frame(grid_sp_df)


# EARTHQUAKES -------------------------------------------------------------

# read in data generated by scrape/get_eq.R
ok_eq = read.csv("rawdata/earthquakes/oklahoma/ok_eq_raw.csv")

# convert longitude/latitude to numeric; add time columns
ok_eq = ok_eq %>%
  mutate(longitude = as.numeric(as.character(longitude)),
         latitude = as.numeric(as.character(latitude)),
         time_year = as.numeric(substr(time, 1, 4)),
         time_dec = floor(time_year/10)*10)

# convert earthquakes data frame to SpatialPoints object
ok_eq_sp = SpatialPoints(ok_eq %>% dplyr::select(longitude, latitude),
                         proj4string = my_crs)

# map earthquakes to oklahoma polygon and filter for only in state
which_ok = over(ok_eq_sp, okl_spolys)
which_ok[which_ok == 1] = "oklahoma"
ok_eq = ok_eq %>%
          mutate(state = which_ok) %>%
          filter(state == "oklahoma")

# map earthquakes spatial points to grid
eq_xy = data.frame(x = ok_eq$longitude,
                   y = ok_eq$latitude,
                   id = "A",
                   stringsAsFactors = F)
coordinates(eq_xy) = ~ x + y 
proj4string(eq_xy) = my_crs
cellIDs = over(eq_xy, grid_sp)
ok_eq$Grid = cellIDs

# colnames(cellIDs) = "Grid"
# ok_eq = bind_cols(ok_eq, cellIDs)


# WELLS -------------------------------------------------------------------

## Read in well locations

well_locs = read.csv("rawdata/wells/oklahoma/all_uic_wells.csv", stringsAsFactors = F)
well_locs = well_locs %>%
  dplyr::select(API=API., Lat=LAT, Long=LONG) %>%
  mutate(API = as.character(API))

## Read in injection data

# read in data generated by scrape/get_inj.R
inj_wells = readRDS("rawdata/wells/oklahoma/raw_injection_wells.rds")

# fill in missing longitude/latitude coordinates
# Note: way too slow; make faster

for (i in 1:nrow(inj_wells)){
  
  # fill in null latitudes
  if (inj_wells$Lat_Y[i] == "NULL"){
    corr_lat = well_locs$Lat[well_locs$API == inj_wells$API[i]]
    inj_wells$Lat_Y[i] = ifelse(length(corr_lat) == 1, corr_lat, NA)
  }
  
  # fill in null longitudes
  if (inj_wells$Long_X[i] == "NULL"){
    corr_long = well_locs$Long[well_locs$API == inj_wells$API[i]]
    inj_wells$Long_X[i] = ifelse(length(corr_long) == 1, corr_long, NA)
  }
}

# remove wells where location is unknown
inj_wells = inj_wells %>%
              filter(is.na(Lat_Y) == F,
                     is.na(Long_X) == F)

## Format such that each well is its own row

# Remove ".Vol" from column names
colnames(inj_wells) = str_replace(colnames(inj_wells), ".Vol", "")

# split data frame by years
inj_wells_split = split(inj_wells, f = inj_wells$ReportYear)

# rename columns for each year to be unique
for (i in 1:length(inj_wells_split)){
  colnames(inj_wells_split[[i]])[5:16] = paste0(names(inj_wells_split)[i],
                                                "-",
                                                colnames(inj_wells_split[[i]])[5:16])
  inj_wells_split[[i]] = inj_wells_split[[i]] %>% dplyr::select(-ReportYear)
}

# bind together by API
wells_wide = Reduce(function(x, y) full_join(x, y, by = c('API', 'Lat_Y', 'Long_X')), 
                    inj_wells_split)

# some duplicate APIs with slightly different or obviously wrong long/lat
# fix by taking max injection for each API
# fix by taking first long/lat unless it's 0; then take the non-zero

# max injections per API
correct_inj = wells_wide %>%
                group_by(API) %>%
                dplyr::select(-API, -Lat_Y, -Long_X) %>%
                mutate_all(max, na.rm = T) %>%
                as.data.frame()

# bind back together
wells_wide = cbind(wells_wide[ , c("API", "Lat_Y", "Long_X")],
                   correct_inj %>% dplyr::select(-API))

# fix lat/long
wells_wide = wells_wide %>%
                mutate(Lat_Y = as.numeric(Lat_Y),
                       Long_X = as.numeric(Long_X)) %>%
                filter(Lat_Y > 33 & Lat_Y < 38,
                       Long_X > -104 & Long_X < -93) %>%
                group_by(API) %>%
                mutate(Lat_Y = ifelse(Lat_Y[1] != 0, Lat_Y[1], Lat_Y[2]),
                       Long_X = ifelse(Long_X[1] != 0, Long_X[1], Long_X[2])) %>%
                as.data.frame() %>%
                distinct()


# mapping wide wells spatial points to grid
wells_wide_xy = data.frame(x = wells_wide$Long_X,
                           y = wells_wide$Lat_Y,
                           id = "A",
                           stringsAsFactors = F)
coordinates(wells_wide_xy) = ~ x + y 
proj4string(wells_wide_xy) = my_crs
cellIDs = over(wells_wide_xy, grid_sp)
wells_wide$Grid = cellIDs

# remove if outside of grid
wells_wide = wells_wide %>% filter(is.na(Grid) == F)

# convert everything to numeric
wells_wide = wells_wide %>% mutate_all(as.numeric)

# mapping wells to oklahoma state; remove if not in state
wells_wide_xy = data.frame(x = wells_wide$Long_X,
                           y = wells_wide$Lat_Y,
                           id = "A",
                           stringsAsFactors = F)
coordinates(wells_wide_xy) = ~ x + y 
proj4string(wells_wide_xy) = my_crs
okIDs = over(wells_wide_xy, okl_spolys)
wells_wide$OK = okIDs
wells_wide = wells_wide %>%
                filter(okIDs == 1) %>%
                dplyr::select(-OK)

# convert wide wells to a SpatialPointsDataFrame
wells_wide_sp = SpatialPointsDataFrame(coords = wells_wide %>% 
                                                  dplyr::select(Long_X, Lat_Y),
                                       data = wells_wide %>% 
                                                dplyr::select(-Long_X, -Lat_Y),
                                       proj4string = my_crs)



# WATER AND EARTHQUAKE BY GRID --------------------------------------------

# flatten water across blocks
grid_inj = wells_wide %>%
  dplyr::select(-API, -Long_X, -Lat_Y) %>%
  group_by(Grid) %>%
  summarise_all(sum, na.rm = T)

# all grid blocks with non-zero water injection
which_no_water = (rowSums(grid_inj %>% dplyr::select(-Grid)) == 0)
grid_inj = grid_inj %>% filter(which_no_water == F)

# all grid blocks with non-zero water injection and non-zero earthquakes
unique_grid = unique(grid_inj$Grid)
how_many = c()
for (i in 1:length(unique_grid)){
  how_many[i] = sum(ok_eq$Grid %in% unique_grid[i])
}

eq_block = data.frame(Grid = unique_grid, earthquakes = how_many)
final_blocks = sort(eq_block$Grid[eq_block$earthquakes > 0])

# final data frames

# convert time in ok_eq to factor with correct levels
y = paste0(2011:2016, ".")
months = c()
for (m in c('01','02','03','04','05','06',
            '07','08','09','10','11','12')){
  months = c(months, paste0(y, m))
}

ok_eq = ok_eq %>%
  mutate(time = as.character(time),
         time = substr(time, 1, 7),
         time = gsub('-', '.', time),
         time = factor(time, levels = months))

# generate earthquake time series
final_eqs = ok_eq %>%
  filter(Grid %in% final_blocks) %>%
  arrange(Grid) %>%
  group_by(Grid) %>%
  dplyr::select(time) %>%
  table() %>%
  matrix(84, 72) %>%
  data.frame()

# final water time series
final_water = grid_inj %>%
  filter(Grid %in% final_blocks) %>%
  arrange(Grid) %>%
  dplyr::select(-Grid)


# SAVING ------------------------------------------------------------------

save.image(file = "ok_data.RData")


# Writing -----------------------------------------------------------------

# write files
write.csv(final_water, file = "data/final_water_ok.csv", row.names = F)
write.csv(final_eqs, file = "data/final_eqs_ok.csv", row.names = F)
write.table(final_blocks, file = "data/final_blocks_ok.txt", row.names = F, col.names = F)


